import { useAccount, useReadContract, useWaitForTransactionReceipt, useWriteContract } from 'wagmi'
import { parseEther, parseUnits, formatEther } from 'viem'
import { useMemo } from 'react'
import { CONTRACT_ADDRESSES, ILK_CBiomaH, RAY } from '@src/lib/contracts-updated'

type IlksTuple = readonly [bigint, bigint, bigint, bigint, bigint]

export function useStablecoin(selectedCollateral: 'CBiomaH' = 'CBiomaH') {
  const { address } = useAccount()
  const addresses = CONTRACT_ADDRESSES.sepolia
  const { writeContractAsync, data: hash, isPending: isWritePending } = useWriteContract()
  const { isPending: isReceiptPending, isSuccess } = useWaitForTransactionReceipt({ hash })
  const isPending = isWritePending || (!!hash && isReceiptPending)

  // Collateral config (single collateral for now)
  const tokenAddress = addresses.cbiomehToken as `0x${string}`
  const joinAddress = addresses.cbiomehJoin as `0x${string}`
  const vatAddress = addresses.vat as `0x${string}`
  const daiJoinAddress = addresses.daiJoin as `0x${string}`
  const ilk = ILK_CBiomaH as `0x${string}`

  // Detect ERC20 decimals for collateral
  const { data: tokenDecimalsData } = useReadContract({
    address: tokenAddress,
    abi: [{ name: 'decimals', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ name: '', type: 'uint8' }] }],
    functionName: 'decimals',
  })
  const tokenDecimals = (typeof tokenDecimalsData === 'number' ? tokenDecimalsData : 18) as number

  // urns(ilk, user): (ink, art)
  const { data: urnData, refetch: refetchUrn } = useReadContract({
    address: vatAddress,
    abi: [
      {
        name: 'urns',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'ilk', type: 'bytes32' },
          { name: 'urn', type: 'address' },
        ],
        outputs: [
          { name: 'ink', type: 'uint256' },
          { name: 'art', type: 'uint256' },
        ],
      },
    ],
    functionName: 'urns',
    args: address ? [ilk, address as `0x${string}`] : undefined,
  })

  const inkWad = (urnData?.[0] ?? 0n) as bigint
  const artWad = (urnData?.[1] ?? 0n) as bigint
  const ink = formatEther(inkWad)
  const art = formatEther(artWad)

  // ilks(ilk): returns (Art, rate, spot, line, dust)
  const { data: ilksData } = useReadContract({
    address: vatAddress,
    abi: [
      {
        name: 'ilks',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'ilk', type: 'bytes32' }],
        outputs: [
          { name: 'Art', type: 'uint256' },
          { name: 'rate', type: 'uint256' },
          { name: 'spot', type: 'uint256' },
          { name: 'line', type: 'uint256' },
          { name: 'dust', type: 'uint256' },
        ],
      },
    ],
    functionName: 'ilks',
    args: [ilk],
  })

  const rateRay = (ilksData ? (ilksData as IlksTuple)[1] : 0n) as bigint
  const spotRay = (ilksData ? (ilksData as IlksTuple)[2] : 0n) as bigint

  // gem(ilk, user): unlocked collateral inside Vat
  const { data: gemData, refetch: refetchGem } = useReadContract({
    address: vatAddress,
    abi: [
      {
        name: 'gem',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'ilk', type: 'bytes32' },
          { name: 'usr', type: 'address' },
        ],
        outputs: [{ name: '', type: 'uint256' }],
      },
    ],
    functionName: 'gem',
    args: address ? [ilk, address as `0x${string}`] : undefined,
  })
  const gemWad = (gemData ?? 0n) as bigint
  const gem = formatEther(gemWad)

  // dai(user): internal dai balance in rad; convert to wad via RAY
  const { data: daiRadData, refetch: refetchDai } = useReadContract({
    address: vatAddress,
    abi: [
      {
        name: 'dai',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'usr', type: 'address' }],
        outputs: [{ name: '', type: 'uint256' }],
      },
    ],
    functionName: 'dai',
    args: address ? [address as `0x${string}`] : undefined,
  })
  const daiRad = (daiRadData ?? 0n) as bigint
  const stableAvailableWad = daiRad / BigInt(RAY)
  const stableAvailable = formatEther(stableAvailableWad)

  // ERC20 wallet balance for collateral token
  const { data: walletErc20Bal } = useReadContract({
    address: tokenAddress,
    abi: [
      { name: 'balanceOf', type: 'function', stateMutability: 'view', inputs: [{ name: 'owner', type: 'address' }], outputs: [{ name: '', type: 'uint256' }] },
    ],
    functionName: 'balanceOf',
    args: address ? [address as `0x${string}`] : undefined,
  })
  const walletTokenBalance = formatEther((walletErc20Bal ?? 0n) as bigint)

  // Compute safe max mint in wad: max(0, floor(ink*spot/rate) - art) with 0.5% buffer
  const safeMaxMintWad = useMemo(() => {
    if (rateRay === 0n || spotRay === 0n) return 0n
    const maxDebt = (inkWad * spotRay) / rateRay
    const room = maxDebt > artWad ? maxDebt - artWad : 0n
    return (room * 995n) / 1000n
  }, [inkWad, artWad, rateRay, spotRay])
  const safeMaxMint = formatEther(safeMaxMintWad)

  // Helpers
  const refresh = () => {
    refetchUrn()
    refetchGem()
    refetchDai()
  }

  // Writes
  const approveToken = async (amount: string, _collateral: 'CBiomaH') => {
    const wad = parseUnits(amount, tokenDecimals)
    return writeContractAsync({
      address: tokenAddress,
      abi: [
        {
          name: 'approve',
          type: 'function',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'spender', type: 'address' },
            { name: 'amount', type: 'uint256' },
          ],
          outputs: [{ name: '', type: 'bool' }],
        },
      ],
      functionName: 'approve',
      args: [joinAddress, wad],
    })
  }

  const depositCollateral = async (amount: string, _collateral: 'CBiomaH') => {
    const wad = parseUnits(amount, tokenDecimals)
    return writeContractAsync({
      address: joinAddress,
      abi: [
        {
          name: 'join',
          type: 'function',
          stateMutability: 'nonpayable',
          inputs: [
            { name: 'usr', type: 'address' },
            { name: 'wad', type: 'uint256' },
          ],
          outputs: [],
        },
      ],
      functionName: 'join',
      args: [address as `0x${string}`, wad],
    })
  }

  const authorizeVat = async () => {
    return writeContractAsync({
      address: vatAddress,
      abi: [
        { name: 'hope', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: 'usr', type: 'address' }], outputs: [] },
      ],
      functionName: 'hope',
      args: [daiJoinAddress],
    })
